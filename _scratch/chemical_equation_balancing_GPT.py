#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# generated by ChatGPT，slightly modified.
"""
Chemical equation balancing + shortest connecting vector (element representation)

数学原理（简要）：
- 记反应物化学式为 R1, R2, ..., Rm，生成物化学式为 P1, P2, ..., Pn。设共有E种元素。
- 将每个化学式用元素基表示，得到反应物矩阵 R (E x m) 与生成物矩阵 P (E x n)。
- 试图找到 r >= 0, p >= 0 使 R r = P p；我们通过约束最小二乘（r,p >=0, sum(r)+sum(p)=1）判断可行。
- 如果不可行，计算最小化 || u - v' ||，其中 u in span(R), v' in span(-P)。
  写作 u - v' = R x + P y = C z (C = [R, P])。在约束 ||z||=1 下，
  最小值为 C 的最小奇异值 sigma_min，对应的单位方向是 U[:, -1]，右奇异向量是 Vt[-1,:]^T。
  我们将在元素基上输出该单位向量（和其模长 sigma_min）。

注意：
- 支持化学式中括号和小数计量（如 La0.9NiSe0.9O1.1）。
- 需要 numpy, scipy。
"""

from __future__ import annotations
import re
from fractions import Fraction
from typing import Dict, List, Tuple

import numpy as np
from numpy.linalg import svd
from fractions import Fraction
from typing import Dict, List, Tuple

import numpy as np
from numpy.linalg import svd
from scipy.optimize import minimize

# ---------- formula parser (supports integer & decimal subscripts, nested parentheses) ----------
_token = re.compile(r"\s*([A-Z][a-z]?|\(|\)|\d+(?:\.\d+)?)\s*")
_number_re = re.compile(r"\d+(?:\.\d+)?$")


def parse_formula(formula: str) -> Dict[str, float]:
    """Parse chemical formula like 'C2H5OH', 'Fe2(SO4)3', 'Ca(OH)2', 'La0.9NiSe0.9O1.1'.
    Return dict element -> count (float allowed)."""
    tokens = _token.findall(formula)
    i = 0

    def parse_group() -> Dict[str, float]:
        nonlocal i
        counts: Dict[str, float] = {}
        while i < len(tokens):
            tok = tokens[i]
            if tok == ')':
                break
            elif tok == '(':
                i += 1
                inner = parse_group()
                if i >= len(tokens) or tokens[i] != ')':
                    raise ValueError(f"Unmatched '(' in formula: {formula}")
                i += 1  # skip ')'
                mult = 1.0
                if i < len(tokens) and _number_re.fullmatch(tokens[i]):
                    mult = float(tokens[i])
                    i += 1
                for el, c in inner.items():
                    counts[el] = counts.get(el, 0.0) + mult * c
            elif _number_re.fullmatch(tok):
                # stand-alone number without preceding element or ')' is syntax error
                raise ValueError(f"Unexpected standalone number at position {i} in {formula}")
            else:
                # element token
                el = tok
                i += 1
                mult = 1.0
                if i < len(tokens) and _number_re.fullmatch(tokens[i]):
                    mult = float(tokens[i])
                    i += 1
                counts[el] = counts.get(el, 0.0) + mult
        return counts

    result = parse_group()
    if i < len(tokens) and tokens[i] == ')':
        raise ValueError(f"Unmatched ')' in formula: {formula}")
    return result


# ---------- build R, P matrices ----------
def build_matrices(reactants: List[str], products: List[str]) -> Tuple[np.ndarray, np.ndarray, List[str]]:
    r_dicts = [parse_formula(x) for x in reactants]
    p_dicts = [parse_formula(x) for x in products]
    elements = sorted(set().union(*r_dicts, *p_dicts))
    E = len(elements)
    R = np.zeros((E, len(reactants)), dtype=float)
    P = np.zeros((E, len(products)), dtype=float)
    for i, el in enumerate(elements):
        for j, d in enumerate(r_dicts):
            R[i, j] = d.get(el, 0.0)
        for j, d in enumerate(p_dicts):
            P[i, j] = d.get(el, 0.0)
    return R, P, elements


# ---------- nullspace via SVD ----------
def nullspace_svd(S: np.ndarray, tol: float = 1e-12) -> np.ndarray:
    """Return orthonormal basis for nullspace as columns (shape n x k)."""
    if S.size == 0:
        return np.zeros((S.shape[1], 0))
    U, s, Vt = svd(S, full_matrices=False)
    if s.size == 0:
        return np.zeros((S.shape[1], 0))
    thresh = tol * max(S.shape) * s[0]
    r = int((s > thresh).sum())
    ns = Vt[r:].T if r < Vt.shape[0] else np.zeros((S.shape[1], 0))
    return ns


# ---------- nonnegative constrained least squares feasibility ----------
def nn_constrained_ls(R: np.ndarray, P: np.ndarray, tol: float = 1e-12):
    """Solve min ||R r - P p||^2  s.t. r>=0, p>=0, sum(r)+sum(p)=1.
    Return r, p, obj (residual squared).
    """
    m = R.shape[1]
    n = P.shape[1]

    def fun(z):
        r = z[:m]
        p = z[m:]
        resid = R @ r - P @ p
        return float(resid @ resid)

    z0 = np.ones(m + n) / (m + n) if (m + n) > 0 else np.array([])
    if z0.size == 0:
        return np.array([]), np.array([]), 1.0
    bounds = [(0.0, None)] * (m + n)
    cons = ({'type': 'eq', 'fun': lambda z: np.sum(z) - 1.0},)
    res = minimize(fun, z0, method='SLSQP', bounds=bounds, constraints=cons,
                   options={'ftol': tol, 'maxiter': 10000})
    # use best found even if not success
    z = np.clip(res.x, 0.0, None)
    s = z.sum()
    if s <= 0:
        z = np.ones_like(z) / len(z)
    else:
        z = z / s
    r = z[:m]
    p = z[m:]
    obj = fun(z)
    return r, p, obj


# ---------- rational/integer scaling ----------
def to_smallest_integers(x: np.ndarray, max_den: int = 1000) -> np.ndarray:
    """Scale nonnegative real vector to smallest coprime integers by rational approximation."""
    if np.allclose(x, 0):
        return np.zeros_like(x, dtype=int)
    pos = x[x > 1e-12]
    if pos.size == 0:
        return np.zeros_like(x, dtype=int)
    y = x / pos.min()
    nums, dens = [], []
    for v in y:
        if v < 1e-12:
            nums.append(0)
            dens.append(1)
        else:
            frac = Fraction(float(v)).limit_denominator(max_den)
            nums.append(frac.numerator)
            dens.append(frac.denominator)
    lcm = 1
    for d in dens:
        lcm = lcm * d // np.gcd(lcm, d)
    ints = (np.array(nums, dtype=int) * lcm // np.array(dens, dtype=int))
    g = 0
    for v in ints:
        g = np.gcd(g, abs(int(v)))
    if g > 1:
        ints //= g
    return ints


# ---------- compute shortest connecting vector (normalized z) ----------
def compute_shortest_vector(R: np.ndarray, P: np.ndarray):
    """
    Compute z (||z||=1) minimizing || R x + P y ||, with z = [x;y].
    Return dict with:
      - v: the element-space vector (R x + P y)  (equals sigma_min * u_min)
      - u_unit: left singular vector U[:, -1] (unit norm)
      - sigma: smallest singular value
      - z: right singular vector (||z||=1)
      - x, y: split of z
    """
    # C = [R, P]
    if R.size == 0 and P.size == 0:
        return {'v': np.array([]), 'u_unit': np.array([]), 'sigma': 0.0, 'z': np.array([]), 'x': np.array([]), 'y': np.array([])}
    C = np.hstack([R, P]) if (R.size and P.size) else (R if P.size == 0 else P)
    U, s, Vt = svd(C, full_matrices=False)
    # if s empty, fallback
    if s.size == 0:
        return {'v': np.zeros(C.shape[0]), 'u_unit': np.zeros(C.shape[0]), 'sigma': 0.0, 'z': np.zeros(C.shape[1]), 'x': np.zeros(R.shape[1]), 'y': np.zeros(P.shape[1])}
    sigma_min = float(s[-1])
    u_min = U[:, -1]
    z_min = Vt.T[:, -1]
    # ensure z_min normalized (should be)
    z_min = z_min / np.linalg.norm(z_min)
    m = R.shape[1] if R.size else 0
    x = z_min[:m] if m > 0 else np.array([])
    y = z_min[m:] if P.size else np.array([])
    v = C @ z_min  # equals sigma_min * u_min (up to numerical sign)
    # flip sign so that first nonzero component of v is positive (for presentation stability)
    for idx in range(v.size):
        if abs(v[idx]) > 1e-12:
            if v[idx] < 0:
                v = -v
                u_min = -u_min
                z_min = -z_min
            break
    return {'v': v, 'u_unit': u_min, 'sigma': sigma_min, 'z': z_min, 'x': x, 'y': y}


# ---------- pretty printing ----------
def format_element_vector(vec: np.ndarray, elements: List[str], thresh: float = 1e-9, digits: int = 6) -> str:
    """Format element-space vector as string like '0.577 La + -0.289 O + ...'."""
    parts = []
    for coef, el in zip(vec, elements):
        if abs(coef) <= thresh:
            continue
        part = f"{round(float(coef), digits):.{digits}f} {el}"
        parts.append(part)
    return " + ".join(parts) if parts else "0"


# ---------- main API ----------
def balance_equation(reactants: List[str], products: List[str], tol: float = 1e-12):
    R, P, elements = build_matrices(reactants, products)
    S = np.hstack([R, -P]) if (R.size or P.size) else np.zeros((0, 0))

    # 1) check structural nullspace (unconstrained)
    NS = nullspace_svd(S, tol=1e-12)
    null_dim = NS.shape[1]

    # 2) constrained nonnegative feasibility (chemical constraint)
    r, p, obj = nn_constrained_ls(R, P, tol=1e-12) if (R.size or P.size) else (np.array([]), np.array([]), 1.0)
    feasible = obj <= 1e-12

    result = {
        'elements': elements,
        'reactants': reactants,
        'products': products,
        'R': R,
        'P': P,
        'S': S,
        'nullity': null_dim,
        'nnls_obj': obj,
        'feasible': feasible,
        'balanced': None,
        'shortest': None,
    }

    if feasible and (r.size or p.size):
        coeff = np.concatenate([r, p])
        ints = to_smallest_integers(coeff)
        rm = len(reactants)
        balanced = {
            'r_float': r,
            'p_float': p,
            'r_int': ints[:rm],
            'p_int': ints[rm:],
        }
        result['balanced'] = balanced
    else:
        # compute shortest connecting vector (normalized z) and present in element basis
        short = compute_shortest_vector(R, P)
        result['shortest'] = short

    return result


def pretty_print_result(res):
    print("Elements:", res['elements'])
    print("Nullity of S (structural):", res['nullity'])
    print("Nonnegative LS residual:", res['nnls_obj'])
    print("Feasible (with nonnegativity)?", res['feasible'])
    if res['balanced'] is not None:
        r_int = res['balanced']['r_int']
        p_int = res['balanced']['p_int']
        left = ' + '.join(f"{(c if c!=1 else '')}{sp}" for c, sp in zip(r_int, res['reactants']))
        right = ' + '.join(f"{(c if c!=1 else '')}{sp}" for c, sp in zip(p_int, res['products']))
        print("Balanced equation:")
        print(left, '->', right)
    else:
        short = res['shortest']
        if short is None:
            print("No shortest vector computed.")
            return
        v = short['v']            # element-space vector (norm = sigma)
        u_unit = short['u_unit']  # unit direction
        sigma = short['sigma']
        z = short['z']           # coefficients on species (x,y) with ||z||=1
        print("=== 不可配平，报告最短向量信息 ===")
        print(f"最小奇异值 (模长) sigma_min = {sigma:.12g}")
        print("最短向量（元素坐标，模长 = sigma_min） v = sigma_min * u_unit :")
        print(format_element_vector(v, res['elements'], digits=6))
        print("单位方向 u_unit (元素坐标，||u_unit||=1) :")
        print(format_element_vector(u_unit, res['elements'], digits=6))
        # 显示 species 上的 z（x;y），它给出如何组合反应物与生成物产生该向量
        m = res['R'].shape[1] if res['R'].size else 0
        if z.size:
            xs = z[:m] if m > 0 else np.array([])
            ys = z[m:] if res['P'].size else np.array([])
            print("对应的物种系数（右奇异向量 z，归一化 ||z||=1）：")
            if xs.size:
                for coef, sp in zip(xs, res['reactants']):
                    print(f"  reactant {sp}: {coef:.6f}")
            if ys.size:
                for coef, sp in zip(ys, res['products']):
                    print(f"  product  {sp}: {coef:.6f}")
        print("说明：此向量表示在元素基上的最短连接方向（在 ||z||=1 归一化下）。")


# ---------- demo ----------
if __name__ == '__main__':
    # Example 1: Combustion of ethanol (balanceable)
    reactants1 = ['C2H5OH', 'O2']
    products1 = ['CO2', 'H2O']
    res1 = balance_equation(reactants1, products1)
    print("=== Example 1: C2H5OH + O2 -> CO2 + H2O ===")
    pretty_print_result(res1)
    print()

    # Example 2: Infeasible: H2 + O2 -> NH3
    reactants2 = ['H2', 'O2']
    products2 = ['NH3']
    res2 = balance_equation(reactants2, products2)
    print("=== Example 2: H2 + O2 -> NH3 (infeasible) ===")
    pretty_print_result(res2)
    print()

    # Example 3: LNSO (contains non-integer stoichiometry on RHS)
    reactants3 = ['La2O3', 'Ni', 'Se', 'La']
    products3 = ['La0.9NiSe0.9O1.1']
    res3 = balance_equation(reactants3, products3)
    print("=== Example 3: LNSO ===")
    pretty_print_result(res3)
